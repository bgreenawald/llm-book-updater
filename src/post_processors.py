import difflib
import re
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional

from loguru import logger


class PostProcessor(ABC):
    """
    Abstract base class for post-processors that clean up LLM-generated content.

    Post-processors take the original block and LLM-generated block and apply
    various cleanup operations to fix errors, improve formatting, or ensure
    consistency.
    """

    def __init__(self, name: str, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the post-processor.

        Args:
            name (str): Name of the post-processor for logging and identification
            config (Optional[Dict[str, Any]]): Configuration parameters for the processor
        """
        self.name = name
        self.config = config or {}
        logger.debug(f"Initialized post-processor: {name}")

    @abstractmethod
    def process(self, original_block: str, llm_block: str, **kwargs) -> str:
        """
        Process the LLM-generated block using the original block as reference.

        Args:
            original_block (str): The original markdown block before LLM processing
            llm_block (str): The block generated by the LLM
            **kwargs: Additional context or parameters

        Returns:
            str: The post-processed block
        """
        pass

    def __str__(self):
        return f"{self.__class__.__name__}(name={self.name})"

    def __repr__(self):
        return self.__str__()


class EnsureBlankLineProcessor(PostProcessor):
    """
    Ensures there is a blank line between any two elements, with exceptions for
    markdown lists and multiline block quotes.

    Quote and Annotation blocks are single-line blocks that should be surrounded
    by blank lines.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__("ensure_blank_line", config)

    def process(self, original_block: str, llm_block: str, **kwargs) -> str:
        lines = llm_block.split("\n")
        processed_lines = []

        for i, line in enumerate(lines):
            processed_lines.append(line)

            if i < len(lines) - 1:
                next_line = lines[i + 1]

                if line.strip() and next_line.strip():
                    # Check for exceptions
                    is_list = line.strip().startswith(("* ", "- ")) and next_line.strip().startswith(("* ", "- "))

                    # Check if we're in a multiline quote block (not Quote/Annotation blocks)
                    in_multiline_quote = self._is_in_multiline_quote(lines, i, line, next_line)

                    if not is_list and not in_multiline_quote:
                        processed_lines.append("")

        return "\n".join(processed_lines)

    def _is_in_multiline_quote(self, lines: List[str], current_idx: int, current_line: str, next_line: str) -> bool:
        """
        Determine if we're in a multiline quote block that should not have
        blank lines inserted between its lines.

        Note: Quote and Annotation blocks are single-line blocks and are
        handled separately.
        """
        # Check if current line starts with quote marker
        if not current_line.strip().startswith(">"):
            return False

        # Check if this is a Quote or Annotation block (single-line)
        if "**Quote:**" in current_line or "**Annotation:**" in current_line:
            return False

        # Check if next line also starts with quote marker
        if next_line.strip().startswith(">"):
            return True

        # Check if we're in the middle of a multiline quote block
        # Look ahead to see if there are more quote lines coming
        for j in range(current_idx + 2, len(lines)):
            future_line = lines[j].strip()
            if not future_line:
                continue
            if future_line.startswith(">"):
                # But not if it's a Quote or Annotation block
                if not ("**Quote:**" in future_line or "**Annotation:**" in future_line):
                    return True
            # If we hit a non-quote line, we're not in a multiline quote
            break

        return False


class RemoveXmlTagsProcessor(PostProcessor):
    """
    Removes XML tags, except for <br>.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__("remove_xml_tags", config)
        self.xml_tag_pattern = re.compile(r"<(?!(/)?br)[^>]*>")

    def process(self, original_block: str, llm_block: str, **kwargs) -> str:
        return self.xml_tag_pattern.sub("", llm_block)


class RemoveTrailingWhitespaceProcessor(PostProcessor):
    """
    Removes trailing whitespace from each line.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__("remove_trailing_whitespace", config)

    def process(self, original_block: str, llm_block: str, **kwargs) -> str:
        return "\n".join(line.rstrip() for line in llm_block.split("\n"))


class RevertRemovedBlockLines(PostProcessor):
    """
    Restores block comment lines (starting with '> ') that were removed by the LLM.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__("revert_removed_block_lines", config)

    def process(self, original_block: str, llm_block: str, **kwargs) -> str:
        original_lines = original_block.splitlines()
        llm_lines = llm_block.splitlines()

        matcher = difflib.SequenceMatcher(None, original_lines, llm_lines)
        processed_lines = list(llm_lines)

        for tag, i1, i2, j1, j2 in reversed(matcher.get_opcodes()):
            if tag == "delete":
                for i in range(i2 - 1, i1 - 1, -1):
                    line = original_lines[i]
                    if line.strip().startswith(">"):
                        logger.info(f"Restoring deleted block line: '{line}'")
                        processed_lines.insert(j1, line)

        return "\n".join(processed_lines)


class NoNewHeadersPostProcessor(PostProcessor):
    """
    Ensures no new markdown headers are added to the content.

    This processor handles two cases:
    1. An entirely new markdown header is added: The new header line is deleted.
    2. An existing line is converted to a markdown header: The line is reverted to its original state.
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__("no_new_headers", config)
        self.header_pattern = re.compile(r"^(#+)\s+(.*)")

    def process(self, original_block: str, llm_block: str, **kwargs) -> str:
        original_lines = original_block.splitlines()
        original_lines_set = set(original_lines)
        original_content_map = {line.strip(): line for line in original_lines}

        llm_lines = llm_block.splitlines()
        processed_lines = []

        for line in llm_lines:
            match = self.header_pattern.match(line)

            if not match:
                processed_lines.append(line)
                continue

            if line in original_lines_set:
                processed_lines.append(line)
                continue

            header_content = match.group(2).strip()

            if header_content in original_content_map:
                original_line = original_content_map[header_content]
                logger.info(f"Reverting converted header: '{line}' to '{original_line}'")
                processed_lines.append(original_line)
            else:
                logger.info(f"Removing new header: '{line}'")

        return "\n".join(processed_lines)


class PostProcessorChain(PostProcessor):
    """
    A chain of post-processors that are applied in sequence.

    Each post-processor in the chain receives the output of the previous
    post-processor, allowing for complex multi-step cleanup operations.
    """

    def __init__(self, processors: Optional[List[PostProcessor]] = None):
        """
        Initialize the post-processor chain.

        Args:
            processors (Optional[List[PostProcessor]]): List of post-processors to chain
        """
        self.processors = processors or []
        logger.debug(f"Initialized post-processor chain with {len(self.processors)} processors")

    def add_processor(self, processor: PostProcessor) -> None:
        """
        Add a post-processor to the end of the chain.

        Args:
            processor (PostProcessor): The post-processor to add
        """
        self.processors.append(processor)
        logger.debug(f"Added post-processor '{processor.name}' to chain")

    def process(self, original_block: str, llm_block: str, **kwargs) -> str:
        """
        Apply all post-processors in the chain sequentially.

        Args:
            original_block (str): The original markdown block
            llm_block (str): The initial LLM-generated block
            **kwargs: Additional context passed to all processors

        Returns:
            str: The final post-processed block
        """
        current_block = llm_block

        for i, processor in enumerate(self.processors):
            try:
                logger.debug(f"Applying post-processor {i + 1}/{len(self.processors)}: {processor.name}")
                current_block = processor.process(original_block, current_block, **kwargs)
                logger.debug(f"Post-processor {processor.name} completed successfully")
            except Exception as e:
                logger.error(f"Error in post-processor {processor.name}: {str(e)}")
                logger.exception("Post-processor error stack trace")
                # Continue with the chain, using the block as-is
                continue

        return current_block

    def __len__(self):
        return len(self.processors)

    def __str__(self):
        return f"PostProcessorChain({[p.name for p in self.processors]})"

    def __repr__(self):
        return self.__str__()
