"""Annotation phase implementations for adding introductions and summaries to blocks."""

from typing import Literal

from loguru import logger

from src.llm.cost_tracking import add_generation_id
from src.phases.base import LlmPhase
from src.phases.utils import contains_only_special_tags, should_skip_by_token_count


class AnnotationPhase(LlmPhase):
    """
    LLM phase that adds annotations to blocks.

    Can prepend (introduction) or append (summary) based on position parameter.
    """

    def __init__(self, name: str, position: Literal["before", "after"] = "after", **kwargs) -> None:
        """
        Initialize annotation phase.

        Args:
            name: Phase name
            position: Where to place annotation ("before" or "after")
            **kwargs: All other LlmPhase parameters
        """
        super().__init__(name=name, **kwargs)
        self.position = position

    def _assemble_processed_block(
        self, current_header: str, current_body: str, llm_response: str, original_body: str, **kwargs
    ) -> str:
        """
        Assemble the block with annotation at configured position.

        Args:
            current_header: The header of the current block
            current_body: The body of the current block
            llm_response: The annotation generated by the LLM
            original_body: The original body for reference
            **kwargs: Additional context

        Returns:
            The block with annotation placed at the configured position
        """
        if self.position == "before":
            return f"{current_header}\n\n{llm_response}\n\n{current_body}\n\n"
        return f"{current_header}\n\n{current_body}\n\n{llm_response}\n\n"

    def _process_block(self, current_block: str, original_block: str, **kwargs) -> str:
        """
        Process a single Markdown block by adding an annotation at the configured position.

        Args:
            current_block (str): The markdown block currently being processed
                (may contain content from previous phases)
            original_block (str): The completely unedited block from the original text
            **kwargs: Additional arguments to pass to the chat completion

        Returns:
            str: The processed markdown block with introduction annotation

        Raises:
            GenerationFailedError: If generation fails and retry is disabled
            MaxRetriesExceededError: If all retry attempts are exhausted
            EmptySectionError: If post-processing detects an invalid empty section
        """
        # Check if block should be skipped based on token count (before processing)
        if should_skip_by_token_count(current_block, self.skip_if_less_than_tokens, self._token_counter):
            current_header, current_body = self._get_header_and_body(current_block)
            return f"{current_header}\n\n{current_body}\n\n"

        current_header, current_body = self._get_header_and_body(current_block)
        original_header, original_body = self._get_header_and_body(original_block)
        tags_to_preserve = self._get_tags_to_preserve()

        # Check if there's any content to process (not empty and not just special tags)
        if (not current_body.strip() and not original_body.strip()) or (
            contains_only_special_tags(current_body, tags_to_preserve)
            and contains_only_special_tags(original_body, tags_to_preserve)
        ):
            logger.debug("Empty block content or content with only special tags, returning block as-is")
            return f"{current_header}\n\n{current_body}\n\n"

        # Use the block content as the user prompt for generating the annotation
        user_prompt = self._format_user_message(current_body, original_body, current_header, original_header)

        if user_prompt:
            # Merge reasoning and llm_kwargs
            call_kwargs = {**self.llm_kwargs, "reasoning": self.reasoning, **kwargs}
            block_info = f"header: {current_header[:50]}"
            annotation, generation_id = self._make_llm_call_with_retry(
                system_prompt=self.system_prompt,
                user_prompt=user_prompt,
                block_info=block_info,
                **call_kwargs,
            )

            # Track generation ID for cost calculation
            add_generation_id(phase_name=self.name, generation_id=generation_id)

            # Apply post-processing to the annotation
            annotation = self._apply_post_processing(current_body, annotation, **kwargs)

            return self._assemble_processed_block(current_header, current_body, annotation, original_body, **kwargs)
        else:
            logger.debug("Empty block body, returning header only")
            return f"{current_header}\n\n"


class IntroductionAnnotationPhase(AnnotationPhase):
    """Adds introduction annotations before block content."""

    def __init__(self, **kwargs) -> None:
        super().__init__(position="before", **kwargs)


class SummaryAnnotationPhase(AnnotationPhase):
    """Adds summary annotations after block content."""

    def __init__(self, **kwargs) -> None:
        super().__init__(position="after", **kwargs)
